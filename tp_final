//EJERCICIO 2 DE PARCIAL

///*

#include "LPC17xx.h"
#include "lpc17xx_dac.h"
#include "lpc17xx_adc.h"
#include "lpc17xx_timer.h"
#include "lpc17xx_pinsel.h"
#include "lpc17xx_gpdma.h"
#include "lpc17xx_exti.h"
#include "lpc17xx_gpio.h"

#define PIN_20 ((uint32_t)(1<<20))
#define PIN_21 ((uint32_t)(1<<21))

	void confPIN();
	//void confTIMER();
	void confADC();
	//void confDAC();
	//void createonda();
	//void confDMA();
	//void confINTGPIO();
	void confEXTINT();
	//void ordenar();
	//void dividir();

//uint32_t wf[1024];
//uint8_t states=0;uint8_t states2=0;
//uint32_t CANTDATOS0=0x2000 / 4; //ya q usamos 32 bits y no 8
//uint32_t parte2mem= 0x2007C000+0x2000;
//uint32_t CANTDATOS1=0x2000 / 4; //ya q usamos 32 bits y no 8
//uint32_t CANTDATOSmuestras=1024;//ya q son la cantidad de muestras necesarias para crear la seÃ±al

int main(){

	confPIN();
	//createonda();
	confEXTINT();
	//confINTGPIO();
	confADC();
	//confDAC();
	//confDMA();

	GPIO_SetValue(1,PIN_21);
	GPIO_SetValue(1,PIN_20);
	//GPIO_ClearValue(1,PIN_20);

while(1){
}

return 0;
}

void confPIN(){
	GPIO_SetDir(1,PIN_20,1);
	GPIO_SetDir(1,PIN_21,1);

	PINSEL_CFG_Type structPINADC0;// ADC
	structPINADC0.Pinnum=23;
	structPINADC0.Portnum=0;
	structPINADC0.Funcnum=1;
	structPINADC0.Pinmode=2;
	PINSEL_ConfigPin(&structPINADC0);

	PINSEL_CFG_Type structPINADC1;// ADC
	structPINADC1.Pinnum=24;
	structPINADC1.Portnum=0;
	structPINADC1.Funcnum=1;
	structPINADC1.Pinmode=2;
	PINSEL_ConfigPin(&structPINADC1);

	PINSEL_CFG_Type structPINEXT0;// PINEXT 2.10
	structPINEXT0.Pinnum=10;
	structPINEXT0.Portnum=2;
	structPINEXT0.Funcnum=1;
	structPINEXT0.Pinmode=0;//pull up
	PINSEL_ConfigPin(&structPINEXT0);

	PINSEL_CFG_Type structPINEXT1;// PINEXT 2.11
	structPINEXT1.Pinnum=11;
	structPINEXT1.Portnum=2;
	structPINEXT1.Funcnum=1;
	structPINEXT1.Pinmode=0;//pull up
	PINSEL_ConfigPin(&structPINEXT1);

}


void confADC(){
	ADC_Init(LPC_ADC,32000);
	//ADC_IntConfig(LPC_ADC,0,ENABLE);
	ADC_ChannelCmd(LPC_ADC,0,ENABLE);
	//ADC_BurstCmd(LPC_ADC_TypeDef *ADCx, ENABLE);
	ADC_StartCmd(LPC_ADC,0);

	//ADC_IntConfig(LPC_ADC,1,ENABLE);
	ADC_ChannelCmd(LPC_ADC,1,ENABLE);
	//ADC_BurstCmd(LPC_ADC_TypeDef *ADCx, ENABLE);
	ADC_StartCmd(LPC_ADC,1);
	//NVIC_EnableIRQ(ADC_IRQn);

}

void confEXTINT(){
	EXTI_Init();
	EXTI_InitTypeDef structEXTINT0;
	structEXTINT0.EXTI_Line=EXTI_EINT0;
	structEXTINT0.EXTI_Mode=EXTI_MODE_LEVEL_SENSITIVE;
	structEXTINT0.EXTI_polarity=EXTI_POLARITY_LOW_ACTIVE_OR_FALLING_EDGE;
	EXTI_Config(&structEXTINT0);
	EXTI_ClearEXTIFlag(EXTI_EINT0);//EINT0 ya q usamos p2.10

	EXTI_InitTypeDef structEXTINT1;
	structEXTINT1.EXTI_Line=EXTI_EINT1;
	structEXTINT1.EXTI_Mode=EXTI_MODE_LEVEL_SENSITIVE;
	structEXTINT1.EXTI_polarity=EXTI_POLARITY_LOW_ACTIVE_OR_FALLING_EDGE;
	EXTI_Config(&structEXTINT1);
	EXTI_ClearEXTIFlag(EXTI_EINT1);

	NVIC_EnableIRQ(EINT0_IRQn);//EINT0 ya q usamos p2.10
	NVIC_EnableIRQ(EINT1_IRQn);//EINT0 ya q usamos p2.11
}


void EINT0_IRQHandler(){

	GPIO_SetValue(1,PIN_20);
	GPIO_ClearValue(1,PIN_21);

	EXTI_ClearEXTIFlag(EXTI_EINT0);
}

void EINT1_IRQHandler(){

	GPIO_SetValue(1,PIN_21);
	GPIO_ClearValue(1,PIN_20);

	EXTI_ClearEXTIFlag(EXTI_EINT1);
}

//void createonda(){
// for(uint8_t i=0;i<512;i--){
//	wf[i]=512+i;
//	wf[512+i]=i;
//}
    //para guardar los datos en la posicion de memoria correspondiente:
//    uint32_t *puntero = wf;
//    uint32_t *posicion_memoria = (uint32_t *)parte2mem; // parte2mem= 0x2007C000+0x2000;

//    for (int i = 0; i < 1024; i++) {
//        *(posicion_memoria + i) = *((uint32_t *)puntero + i);
//    }
//}

//void dividir(){
//    uint32_t *posicion_memoria = (uint32_t *)0x2007C000;
//    for (uint32_t i = 0; i < (0x2000/4); i++) {// 0x2000/4 = cant de datos(muestras)
//        *(posicion_memoria + i) = (*posicion_memoria + i)/4;
//    }
//}

//*/
