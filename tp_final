/*	TRABAJO TP FINAL ELECTRONICA DIGITAL
*	GRUPO 10
*/ 

#include "LPC17xx.h"
#include "lpc17xx_dac.h"
#include "lpc17xx_adc.h"
#include "lpc17xx_timer.h"
#include "lpc17xx_pinsel.h"
#include "lpc17xx_gpdma.h"
#include "lpc17xx_exti.h"
#include "lpc17xx_gpio.h"
#include "lpc17xx_uart.h"

#include <stdio.h>
#include <string.h>
#include <math.h>
#include <stdint.h>
#include <stdbool.h>	// para booleano

#define PIN_20 ((uint32_t)(1<<20))
#define PIN_21 ((uint32_t)(1<<21))

volatile uint16_t ValRecHum[10];//valores recibidos desde el adc
volatile uint8_t ValSentHum[1]; //valor a enviar por transmision

uint8_t se単alHum[]={0x48,'\n','\r'};//0x48 =H para sincronizar con la app de matalb
uint8_t se単alTem[]={0x31,'\n','\r'};//0x54 =T para sincronizar con la app de matalb

volatile uint8_t ValRecTem[10];
volatile uint8_t ValSentTem[1];

uint8_t pul0=1;
uint8_t pul1=1;

	void confPIN();
	void configADC();// convierte la se単al analogica del sensor analogico,en digital

	void confDMA();// configuramos el canal para mandar los datos sensor analogico por uart usando dma

	void confEXTINT();
	void confUart();

	void confTIMER1();// timer para mandar cada 2 segundos la tranmision uart de los datos del sensor analogico
	void confTIMER2();// timer para mandar cada 2 segundos la tranmision uart de los datos del sensor digital
	void confDMA2();// configuramos el canal para mandar los datos sensor digital por uart usando dma
	void confDMA3();

int main(){
	uint32_t value=0;// sirve para el breakpoint de despues
	GPIO_ClearValue(1,PIN_20);
	GPIO_ClearValue(1,PIN_21);

	confPIN(); //configuramos todos los pines
	confEXTINT();

	confUart();
	configADC();
	confDMA();
	confDMA2();
	confDMA3();

	confTIMER1();
	confTIMER2();

	TIM_ResetCounter(LPC_TIM1);
	TIM_ResetCounter(LPC_TIM2);

	while(1){
		value++;// poner un breakpoint aca e ir apretando resumen para ver como funciona
	}

	return 0;
}

void confPIN(){
	GPIO_SetDir(1,PIN_20,1);
	GPIO_SetDir(1,PIN_21,1);

	//GPIO_SetDir(0,0,1);// todo VER ESTO .pin que va a recibir el dato proveniente del sensor digital.

	PINSEL_CFG_Type structPINADC3;// ADC0.3 - sensor de humedad
	structPINADC3.Pinnum=26;
	structPINADC3.Portnum=0;
	structPINADC3.Funcnum=1;
	structPINADC3.Pinmode=2;
	PINSEL_ConfigPin(&structPINADC3);

	PINSEL_CFG_Type structPINADC4;// ADC0.4 - sensor de temperatura
	structPINADC4.Pinnum=30;
	structPINADC4.Portnum=1;
	structPINADC4.Funcnum=3;
	structPINADC4.Pinmode=2;
	PINSEL_ConfigPin(&structPINADC4);

	PINSEL_CFG_Type structPINEXT0;// PINEXT 2.10. LED AZUL
	structPINEXT0.Pinnum=10;
	structPINEXT0.Portnum=2;
	structPINEXT0.Funcnum=1;
	structPINEXT0.Pinmode=0;//pull up
	PINSEL_ConfigPin(&structPINEXT0);

	PINSEL_CFG_Type structPINEXT1;// PINEXT 2.11. LED ROJO
	structPINEXT1.Pinnum=11;
	structPINEXT1.Portnum=2;
	structPINEXT1.Funcnum=1;
	structPINEXT1.Pinmode=0;//pull up
	PINSEL_ConfigPin(&structPINEXT1);

	PINSEL_CFG_Type PinCfg;
	//configuracion pin de TX2 y RX2
	PinCfg.Funcnum = 1;
	PinCfg.OpenDrain = 0;
	PinCfg.Pinmode = 0;
	PinCfg.Pinnum = 10;
	PinCfg.Portnum = 0;
	PINSEL_ConfigPin(&PinCfg);
	PinCfg.Pinnum = 11;
	PINSEL_ConfigPin(&PinCfg);
	return;

	PINSEL_CFG_Type PinCfg2; // para lora uart
	//configuracion pin de TXD0 y RXD0
	PinCfg2.Funcnum = 1;
	PinCfg2.OpenDrain = 0;
	PinCfg2.Pinmode = 0;
	PinCfg2.Pinnum = 2;
	PinCfg2.Portnum = 0;
	PINSEL_ConfigPin(&PinCfg2);
	PinCfg2.Pinnum = 3;
	PINSEL_ConfigPin(&PinCfg2);
	return;

}

void confTIMER1() // timer para mandar cada 1 segundo la tranmision uart
{
	TIM_TIMERCFG_Type    struct_config;
	TIM_MATCHCFG_Type    struct_match;

	struct_config.PrescaleOption    =    TIM_PRESCALE_TICKVAL;
	struct_config.PrescaleValue     =    1;

	struct_match.MatchChannel       =    0;
	struct_match.IntOnMatch         =    ENABLE; //habilitamos las interrupciones por timer
	struct_match.ResetOnMatch       =    ENABLE;//resetea el contador del timer cuando se produce un match
	struct_match.StopOnMatch        =    DISABLE; //no detiene el contador del timer cuando se produce un match
	struct_match.ExtMatchOutputType =    TIM_EXTMATCH_NOTHING;

	struct_match.MatchValue         =    25000000-1;//1 segundo

	TIM_Init(LPC_TIM1, TIM_TIMER_MODE, &struct_config); //se prende el timer0, se configura la division del clock del periferico, y se
	//configura el timer como modo temporizador y ademas se retesea el contador y se lo saca del reset
	TIM_ConfigMatch(LPC_TIM1, &struct_match); //carga todas las configuraciones del struct_match en ls registros correspondientes

	TIM_ResetCounter(LPC_TIM1);
	TIM_Cmd(LPC_TIM1, ENABLE); //habilita el contador del timer

	NVIC_EnableIRQ(TIMER1_IRQn);

	return;
}

void confTIMER2()// timer para mandar cada 2 segundos la lectura del pin0.0, donde esta el sensor digital
{
	TIM_TIMERCFG_Type    struct_config;
	TIM_MATCHCFG_Type    struct_match;

	struct_config.PrescaleOption    =    TIM_PRESCALE_TICKVAL;
	struct_config.PrescaleValue     =    1;

	struct_match.MatchChannel       =    0;
	struct_match.IntOnMatch         =    ENABLE; //habilitamos las interrupciones por timer
	struct_match.ResetOnMatch       =    ENABLE;//resetea el contador del timer cuando se produce un match
	struct_match.StopOnMatch        =    DISABLE; //no detiene el contador del timer cuando se produce un match
	struct_match.ExtMatchOutputType =    TIM_EXTMATCH_NOTHING;

	struct_match.MatchValue         =    50000000-1;//2 segundos

	TIM_Init(LPC_TIM2, TIM_TIMER_MODE, &struct_config); //se prende el timer2, se configura la division del clock del periferico, y se
	//configura el timer como modo temporizador y ademas se retesea el contador y se lo saca del reset
	TIM_ConfigMatch(LPC_TIM2, &struct_match); //carga todas las configuraciones del struct_match en ls registros correspondientes

	TIM_ResetCounter(LPC_TIM2);
	TIM_Cmd(LPC_TIM2, ENABLE); //habilita el contador del timer

	NVIC_EnableIRQ(TIMER2_IRQn);

	return;
}

void configADC()// convierte la se単al analogica del sensor analogico,en digital
{
	///CONFIGURACION ADC: -----------------///
	 //Nuestro CCLK es de 100MHz y configuramos el divisor de periferico a 8
	 //CCLK/divP = 100MHz/8 = 12,5MHz
	 //Al utilizar el modo controlado necesito 65 ciclos de reloj
	 //para establecer la muestra.
	 //12,5MHz/65 = 195312 Hz, siendo la frecuencia de trabajo maxima configurable
	//-------------------------------------

	LPC_SC->PCLKSEL0 |=(3<<24);
	ADC_Init(LPC_ADC, 100000); //ENCIENDO ADC
	ADC_ChannelCmd(LPC_ADC, ADC_CHANNEL_3,ENABLE);
	ADC_ChannelCmd(LPC_ADC, ADC_CHANNEL_4,ENABLE);
	ADC_StartCmd(LPC_ADC, ADC_START_CONTINUOUS);//ADC_START_CONTINUOUS=0
	ADC_BurstCmd(LPC_ADC, DISABLE);//Modo burst

	return;
}

void confUart(){
	UART_CFG_Type UARTConfigStruct;//variable auxiliar. es una estructura que es utilizada por las funciones del driver  para mostrar/sacar valores para realizar la configuracion
	UART_FIFO_CFG_Type UARTFIFOConfigStruct;
	UART_ConfigStructInit(&UARTConfigStruct);
	//inicializa perif rico
	UART_Init(LPC_UART2, &UARTConfigStruct);

	//UART_FIFOConfigStructInit(&UARTFIFOConfigStruct);
	UARTFIFOConfigStruct.FIFO_DMAMode = ENABLE;        // Habilita la escritura de la FIFO por DMA
	UARTFIFOConfigStruct.FIFO_DMAMode = ENABLE;
	UARTFIFOConfigStruct.FIFO_Level = UART_FIFO_TRGLEV0;
	UARTFIFOConfigStruct.FIFO_ResetRxBuf = ENABLE;
	UARTFIFOConfigStruct.FIFO_ResetTxBuf = ENABLE;

	//Inicializa FIFO
	UART_FIFOConfig(LPC_UART2, &UARTFIFOConfigStruct);//funcion que lleva a cabo la inicializacion
	//Habilita transmisi n
	UART_TxCmd(LPC_UART2, ENABLE);
	return;
}

void confEXTINT(){
	EXTI_Init();
	EXTI_InitTypeDef structEXTINT0;
	structEXTINT0.EXTI_Line=EXTI_EINT0;//led azul
	structEXTINT0.EXTI_Mode=EXTI_MODE_LEVEL_SENSITIVE;
	structEXTINT0.EXTI_polarity=EXTI_POLARITY_LOW_ACTIVE_OR_FALLING_EDGE;
	EXTI_Config(&structEXTINT0);
	EXTI_ClearEXTIFlag(EXTI_EINT0);//EINT0 ya q usamos p2.10

	EXTI_InitTypeDef structEXTINT1;
	structEXTINT1.EXTI_Line=EXTI_EINT1;//led rojo
	structEXTINT1.EXTI_Mode=EXTI_MODE_LEVEL_SENSITIVE;
	structEXTINT1.EXTI_polarity=EXTI_POLARITY_LOW_ACTIVE_OR_FALLING_EDGE;
	EXTI_Config(&structEXTINT1);
	EXTI_ClearEXTIFlag(EXTI_EINT1);

	NVIC_EnableIRQ(EINT0_IRQn);//EINT0 ya q usamos p2.10
	NVIC_EnableIRQ(EINT1_IRQn);//EINT0 ya q usamos p2.11
}

void EINT0_IRQHandler(){//led azul
	if(pul0==0){
		pul0=1;
	}else{
		pul0=0;
	}

	if(pul0){//pul0==1 apagado led
		GPIO_ClearValue(1,PIN_20);
	}else{//pul0==0 prendido led
		GPIO_SetValue(1,PIN_20);
	}

	EXTI_ClearEXTIFlag(EXTI_EINT0);
}

void EINT1_IRQHandler(){ //led rojo
	if(pul1==0){
		pul1=1;
	}else{
		pul1=0;
	}
	if(pul1){//pul0==1 apagado led
		GPIO_ClearValue(1,PIN_21);
	}else{//pul0==0 prendido led
		GPIO_SetValue(1,PIN_21);
	}

	EXTI_ClearEXTIFlag(EXTI_EINT1);
}

void confDMA() // configuramos el canal para mandar los datos del sensor analogico de humedad por uart usando dma
{
	NVIC_DisableIRQ(DMA_IRQn);

	GPDMA_Init();                // Inicializo el controlador de DMA

	GPDMA_Channel_CFG_Type DMAUARTConfig;
	DMAUARTConfig.ChannelNum = 1;
	DMAUARTConfig.SrcMemAddr = (uint32_t)(ValSentHum);
	DMAUARTConfig.DstMemAddr = 0;
	DMAUARTConfig.TransferSize = sizeof(ValSentHum);
	DMAUARTConfig.TransferWidth = 0;
	DMAUARTConfig.TransferType = GPDMA_TRANSFERTYPE_M2P;
	DMAUARTConfig.SrcConn = 0;
	DMAUARTConfig.DstConn = GPDMA_CONN_UART2_Tx;
	DMAUARTConfig.DMALLI = 0;

	GPDMA_Setup(&DMAUARTConfig);

	return;
}

void confDMA2() // configuramos el canal para mandar los datos del sensor analog de temp por uart usando dma
{

	NVIC_DisableIRQ(DMA_IRQn);

	GPDMA_Init();                // Inicializo el controlador de DMA

	GPDMA_Channel_CFG_Type DMAUARTConfig;
	DMAUARTConfig.ChannelNum = 2;
	DMAUARTConfig.SrcMemAddr = (uint32_t)(ValSentTem);
	DMAUARTConfig.DstMemAddr = 0;
	DMAUARTConfig.TransferSize = sizeof(ValSentTem); 
	DMAUARTConfig.TransferWidth = 0;
	DMAUARTConfig.TransferType = GPDMA_TRANSFERTYPE_M2P;
	DMAUARTConfig.SrcConn = 0;
	DMAUARTConfig.DstConn = GPDMA_CONN_UART2_Tx;
	DMAUARTConfig.DMALLI = 0;

	GPDMA_Setup(&DMAUARTConfig);

	return;
}

void confDMA3() //// configuramos el canal para mandar los datos del ADC (humedad) a memoria (un array)
{
	GPDMA_LLI_Type LLI1;
		LLI1.SrcAddr = (uint32_t) &LPC_ADC->ADDR3; // fuente es el adc canal 3
		LLI1.DstAddr = (uint32_t) ValRecHum;
		LLI1.NextLLI = 0;
		LLI1.Control = sizeof(ValRecHum)
					   | (1<<18) //source width 16 bits
					   | (1<<21) //dest width 16 bits
					   | (1<<27); //destino increment
		
	GPDMA_Channel_CFG_Type DMAConfig;

	NVIC_DisableIRQ(DMA_IRQn);

	GPDMA_Init();                // Inicializo el controlador de DMA

	DMAConfig.ChannelNum = 3;
	DMAConfig.SrcMemAddr = 0;
	DMAConfig.DstMemAddr = (uint32_t)(ValRecHum);
	DMAConfig.TransferSize = sizeof(ValRecHum);
	DMAConfig.TransferWidth = 0;
	DMAConfig.TransferType = GPDMA_TRANSFERTYPE_P2M;
	DMAConfig.SrcConn = GPDMA_CONN_ADC;
	DMAConfig.DstConn = 0;
	DMAConfig.DMALLI = (uint32_t) &LLI1;

	GPDMA_Setup(&DMAConfig);
	NVIC_EnableIRQ(DMA_IRQn);

	return;
}

void confDMA4() //// configuramos el canal para mandar los datos del ADC(temp) a memoria (un array)
{
	GPDMA_LLI_Type LLI1;
		LLI1.SrcAddr = (uint32_t) &LPC_ADC->ADDR4; // fuente es el adc canal 3
		LLI1.DstAddr = (uint32_t) ValRecTem;
		LLI1.NextLLI = 0;
		LLI1.Control = sizeof(ValRecTem)
					   | (1<<18) //source width 16 bits
					   | (1<<21) //dest width 16 bits
					   | (1<<27); //destino increment

	GPDMA_Channel_CFG_Type DMAConfig;

	NVIC_DisableIRQ(DMA_IRQn);

	GPDMA_Init();                // Inicializo el controlador de DMA

	DMAConfig.ChannelNum = 4;
	DMAConfig.SrcMemAddr = 0;
	DMAConfig.DstMemAddr = (uint32_t)(ValRecTem);
	DMAConfig.TransferSize = sizeof(ValRecTem);
	DMAConfig.TransferWidth = 0;
	DMAConfig.TransferType = GPDMA_TRANSFERTYPE_P2M;
	DMAConfig.SrcConn = GPDMA_CONN_ADC;
	DMAConfig.DstConn = 0;
	DMAConfig.DMALLI = (uint32_t) &LLI1;

	GPDMA_Setup(&DMAConfig);
	NVIC_EnableIRQ(DMA_IRQn);
	
	return;
}

void DMA_IRQHandler (){// todo . ver si esto esta bien al usar los dos sensores al mismo tiempo
	if (GPDMA_IntGetStatus(GPDMA_STAT_INT, 3)){
		if(GPDMA_IntGetStatus(GPDMA_STAT_INTTC, 3)){// Chequeo que la interrupcion sea por Terminal Count

			GPDMA_ClearIntPending (GPDMA_STATCLR_INTTC, 3);

			ADC_BurstCmd(LPC_ADC, 0);               // El ADC deja de convertir

		}
	}else if(GPDMA_IntGetStatus(GPDMA_STAT_INT, 4)){
		if(GPDMA_IntGetStatus(GPDMA_STAT_INTTC, 4)){// Chequeo que la interrupcion sea por Terminal Count

			GPDMA_ClearIntPending (GPDMA_STATCLR_INTTC, 4);

			ADC_BurstCmd(LPC_ADC, 0);               // El ADC deja de convertir

		}
	}
	return;
}

void TIMER1_IRQHandler()// handler del timer para mandar datos por uart. cada 1 segundo
					    //y para activar el adc para humedad.
{
	static uint16_t val=0;
	if(pul0==0){// osea si el led azul esta prendido

		//-------- recibir del adc
		ADC_BurstCmd(LPC_ADC, ENABLE);
		confDMA3();
		GPDMA_ChannelCmd(3, ENABLE);
		//---------------------------------


		// Parte nueva:
		val=0;
		for(uint8_t i=0;i<10;i++){
			val=val + ValRecHum[i];
		}
		val=(val>>4);// corremos 4 lugares ya q el adc es de 12 y el uart manda de 8

		//val = 100 - (hum_suelo * 100) / 1023; // TODO formula para obtener el valor de humedad (de valor a porcentaje)

		ValSentHum[0]=val;

		UART_Send(LPC_UART2,se単alHum,sizeof(se単alHum), BLOCKING);
		


		//------- enviar por uart
		confDMA();
		GPDMA_ChannelCmd(1,ENABLE);
		//--------------------------

		//-------------------
		   // ACA HABRIA QUE PONER PARA MANDAR POR LORA
		//--------------
	}
	TIM_ClearIntPending(LPC_TIM1,TIM_MR0_INT);

	return;
}

void TIMER2_IRQHandler()//2 segundos.hanndler del timer para mandar datos del sensor digital por uart
						//y para activar el adc para temperatura.
{
	static uint16_t val=0;
	if(pul1==0){// osea si el led rojo esta encendido

		//-------- recibir del adc
		ADC_BurstCmd(LPC_ADC, ENABLE);
		confDMA4();
		GPDMA_ChannelCmd(4, ENABLE);
		//---------------------------------


		// Parte nueva:
		val=0;
		for(uint8_t i=0;i<10;i++){
			val=val + ValRecTem[i];
		}
		val=(val>>4);// corremos 4 lugares ya q el adc es de 12 y el uart manda de 8

		val= (val*5*100)/4095; // obtenemos el valor de temperatura

		ValSentTem[0]=val;

		UART_Send(LPC_UART2,se単alTem, sizeof(se単alTem), BLOCKING);

		//------- enviar por uart
		confDMA2();
		GPDMA_ChannelCmd(2,ENABLE);
		//--------------------------

		//-------------------
		   // ACA HABRIA QUE PONER PARA MANDAR POR LORA
		//--------------
	}
	TIM_ClearIntPending(LPC_TIM2,TIM_MR0_INT);

	return;
}