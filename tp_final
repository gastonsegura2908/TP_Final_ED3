//ANDA SIN CONECTAR EL USB DE TRANMISION A LA COMPU

///*

#include "LPC17xx.h"
#include "lpc17xx_dac.h"
#include "lpc17xx_adc.h"
#include "lpc17xx_timer.h"
#include "lpc17xx_pinsel.h"
#include "lpc17xx_gpdma.h"
#include "lpc17xx_exti.h"
#include "lpc17xx_gpio.h"
#include "lpc17xx_uart.h"
#include <stdio.h>
#include <string.h>
#include <math.h>
#include <stdint.h>

#define PIN_20 ((uint32_t)(1<<20))
#define PIN_21 ((uint32_t)(1<<21))

volatile uint16_t ADC0Value = 0;
volatile uint16_t ADC1Value = 0;
//
uint8_t ADC0Value8 = 0;
//uint8_t resultado[10];

uint8_t prueba2=0;
	void confPIN();
	//void confTIMER();
	void configADC();
	//void confDAC();
	//void createonda();
	//void confDMA();
	//void confINTGPIO();
	void confEXTINT();
	void config_timer_0();
	void confUart();
	//void ordenar();
	//void dividir();

//uint32_t wf[1024];
//uint8_t states=0;uint8_t states2=0;
//uint32_t CANTDATOS0=0x2000 / 4; //ya q usamos 32 bits y no 8
//uint32_t parte2mem= 0x2007C000+0x2000;
//uint32_t CANTDATOS1=0x2000 / 4; //ya q usamos 32 bits y no 8
//uint32_t CANTDATOSmuestras=1024;//ya q son la cantidad de muestras necesarias para crear la seÃ±al

int main(){
	uint32_t value=0;
	confPIN();
	//createonda();
	config_timer_0();
	confEXTINT();
	//confINTGPIO();
	confUart();
	configADC();
	//confDAC();
	//confDMA();

	GPIO_SetValue(1,PIN_21);
	GPIO_SetValue(1,PIN_20);
	//GPIO_ClearValue(1,PIN_20);
	TIM_ResetCounter(LPC_TIM0);
	while(1){
		value++;
	}

return 0;
}

void confPIN(){
	GPIO_SetDir(1,PIN_20,1);
	GPIO_SetDir(1,PIN_21,1);

	PINSEL_CFG_Type structPINADC0;// ADC0.0
	structPINADC0.Pinnum=23;
	structPINADC0.Portnum=0;
	structPINADC0.Funcnum=1;
	structPINADC0.Pinmode=2;
	PINSEL_ConfigPin(&structPINADC0);

	PINSEL_CFG_Type structPINADC1;// ADC0.1
	structPINADC1.Pinnum=24;
	structPINADC1.Portnum=0;
	structPINADC1.Funcnum=1;
	structPINADC1.Pinmode=2;
	PINSEL_ConfigPin(&structPINADC1);

	PINSEL_CFG_Type structPINEXT0;// PINEXT 2.10
	structPINEXT0.Pinnum=10;
	structPINEXT0.Portnum=2;
	structPINEXT0.Funcnum=1;
	structPINEXT0.Pinmode=0;//pull up
	PINSEL_ConfigPin(&structPINEXT0);

	PINSEL_CFG_Type structPINEXT1;// PINEXT 2.11
	structPINEXT1.Pinnum=11;
	structPINEXT1.Portnum=2;
	structPINEXT1.Funcnum=1;
	structPINEXT1.Pinmode=0;//pull up
	PINSEL_ConfigPin(&structPINEXT1);

	PINSEL_CFG_Type structPINMAT;// PIN MATCH MAT0.1, P3.26
	structPINMAT.Pinnum=26;
	structPINMAT.Portnum=3;
	structPINMAT.Funcnum=2;
	structPINMAT.Pinmode=0;//pull up
	PINSEL_ConfigPin(&structPINMAT);

	PINSEL_CFG_Type PinCfg;
	//configuraci n pin de Tx y Rx
	PinCfg.Funcnum = 1;
	PinCfg.OpenDrain = 0;
	PinCfg.Pinmode = 0;
	PinCfg.Pinnum = 10;
	PinCfg.Portnum = 0;
	PINSEL_ConfigPin(&PinCfg);
	PinCfg.Pinnum = 11;
	PINSEL_ConfigPin(&PinCfg);
	return;

}

void config_timer_0()
{
	TIM_TIMERCFG_Type    struct_config;
	TIM_MATCHCFG_Type    struct_match;


	struct_config.PrescaleOption    =    TIM_PRESCALE_TICKVAL;
	struct_config.PrescaleValue     =    1;

	struct_match.MatchChannel       =    1;
	struct_match.IntOnMatch         =    DISABLE; //deshabilitamos las interrupciones por timer
	struct_match.ResetOnMatch       =    ENABLE;//resetea el contador del timer cuando se produce un match
	struct_match.StopOnMatch        =    DISABLE; //no detiene el contador del timer cuando se produce un match
	struct_match.ExtMatchOutputType =    TIM_EXTMATCH_TOGGLE;



	struct_match.MatchValue         =    25000000-1;

	TIM_Init(LPC_TIM0, TIM_TIMER_MODE, &struct_config); //se prende el timer0, se configura la division del clock del periferico, y se
	//configura el timer como modo temporizador y ademas se retesea el contador y se lo saca del reset
	TIM_ConfigMatch(LPC_TIM0, &struct_match); //carga todas las configuraciones del struct_match en ls registros correspondientes

	TIM_ResetCounter(LPC_TIM0);
	TIM_Cmd(LPC_TIM0, ENABLE); //habilita el contador del timer y prescaler

	return;
}

void configADC()
{
	///CONFIGURACION ADC: -----------------///
	 //Nuestro CCLK es de 100MHz y configuramos el divisor de periferico a 8
	 //CCLK/divP = 100MHz/8 = 12,5MHz
	 //Al utilizar el modo controlado necesito 65 ciclos de reloj
	 //para establecer la muestra.
	 //12,5MHz/65 = 195312 Hz, siendo la frecuencia de trabajo maxima configurable
	//-------------------------------------

	ADC_Init(LPC_ADC, 40000); //ENCIENDO ADC
	ADC_ChannelCmd(LPC_ADC, ADC_CHANNEL_0,ENABLE); //POR CANAL 0
	//ADC_ChannelCmd(LPC_ADC, ADC_CHANNEL_1,ENABLE); //POR CANAL 1
	ADC_StartCmd(LPC_ADC, ADC_START_ON_MAT01);    //START CON MATCH, DEBE MUESTREAR CADA 1 SEG
	//ADC_EdgeStartConfig(LPC_ADC, ADC_START_ON_RISING); //Arranca por Mat0.1 en alto
	ADC_EdgeStartConfig(LPC_ADC, ADC_START_ON_FALLING); //Arranca por Mat0.1 en bajo
	ADC_BurstCmd(LPC_ADC, DISABLE);//Modo controlado
	ADC_IntConfig(LPC_ADC, ADC_ADGINTEN, SET);//Activo las interrupciones

	ADC_GlobalGetStatus(LPC_ADC, 1); //Bajo la bandera
	NVIC_EnableIRQ(ADC_IRQn);

	return;
}

void ADC_IRQHandler() 	// PONER PARA QUE LANCE UART
{
	//static uint8_t *puntero=0;
	ADC0Value = ADC_ChannelGetData(LPC_ADC, ADC_CHANNEL_0);
	//ADC1Value = ADC_ChannelGetData(LPC_ADC, ADC_CHANNEL_1);

	//*puntero=((ADC0Value>>4) & (0xFF));
	//uint8_t puntero[3] = {ADC0Value,'\n','\r'};
	//uint8_t info[]={0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39,0x30,'\n','\r'};
	//UART_Send(LPC_UART2, puntero, 3, BLOCKING);

	ADC_GlobalGetStatus(LPC_ADC, 1);

	return;
}



void confUart(){
	UART_CFG_Type UARTConfigStruct;//variable auxiliar. es una estructura que es utilizada por las funciones del driver  para mostrar/sacar valores para realizar la configuracion
	UART_FIFO_CFG_Type UARTFIFOConfigStruct;
	UART_ConfigStructInit(&UARTConfigStruct);
	//inicializa perif rico
	UART_Init(LPC_UART2, &UARTConfigStruct);

	UART_FIFOConfigStructInit(&UARTFIFOConfigStruct);
	//UARTFIFOConfigStruct.FIFO_DMAMode = ENABLE;        // Habilita la escritura de la FIFO por DMA
	//UARTFIFOConfigStruct.FIFO_DMAMode = ENABLE;
	//UARTFIFOConfigStruct.FIFO_Level = UART_FIFO_TRGLEV0;
	//UARTFIFOConfigStruct.FIFO_ResetRxBuf = ENABLE;
	//UARTFIFOConfigStruct.FIFO_ResetTxBuf = ENABLE;


	//Inicializa FIFO
	UART_FIFOConfig(LPC_UART2, &UARTFIFOConfigStruct);//funcion que lleva a cabo la inicializacion
	//Habilita transmisi n
	UART_TxCmd(LPC_UART2, ENABLE);
	return;
}
void confEXTINT(){
	EXTI_Init();
	EXTI_InitTypeDef structEXTINT0;
	structEXTINT0.EXTI_Line=EXTI_EINT0;
	structEXTINT0.EXTI_Mode=EXTI_MODE_LEVEL_SENSITIVE;
	structEXTINT0.EXTI_polarity=EXTI_POLARITY_LOW_ACTIVE_OR_FALLING_EDGE;
	EXTI_Config(&structEXTINT0);
	EXTI_ClearEXTIFlag(EXTI_EINT0);//EINT0 ya q usamos p2.10

	EXTI_InitTypeDef structEXTINT1;
	structEXTINT1.EXTI_Line=EXTI_EINT1;
	structEXTINT1.EXTI_Mode=EXTI_MODE_LEVEL_SENSITIVE;
	structEXTINT1.EXTI_polarity=EXTI_POLARITY_LOW_ACTIVE_OR_FALLING_EDGE;
	EXTI_Config(&structEXTINT1);
	EXTI_ClearEXTIFlag(EXTI_EINT1);

	NVIC_EnableIRQ(EINT0_IRQn);//EINT0 ya q usamos p2.10
	NVIC_EnableIRQ(EINT1_IRQn);//EINT0 ya q usamos p2.11
}


void EINT0_IRQHandler(){

	GPIO_SetValue(1,PIN_20);
	GPIO_ClearValue(1,PIN_21);

	EXTI_ClearEXTIFlag(EXTI_EINT0);
}

void EINT1_IRQHandler(){

	GPIO_SetValue(1,PIN_21);
	GPIO_ClearValue(1,PIN_20);

	EXTI_ClearEXTIFlag(EXTI_EINT1);
}

//void ADC_IRQHandler() 	// PONER PARA QUE LANCE UART
//{
	//if(ADC_ChannelGetStatus(LPC_ADC,0,ADC_DATA_DONE)){
	//ADC0Value = ADC_ChannelGetData(LPC_ADC, ADC_CHANNEL_0);
	//uint8_t puntero0[3] = {ADC0Value,'\n','\r'};
	//UART_Send(LPC_UART2, puntero0, 3, BLOCKING);
	//}else if(LPC_ADC,1,ADC_DATA_DONE){
	//ADC1Value = ADC_ChannelGetData(LPC_ADC, ADC_CHANNEL_1);
	//uint8_t puntero1[3] = {ADC1Value,'\n','\r'};
	//UART_Send(LPC_UART2, puntero1, 3, BLOCKING);
	//}
	//ADC_GlobalGetStatus(LPC_ADC, 1);

	//return;
//}


//void createonda(){
// for(uint8_t i=0;i<512;i--){
//	wf[i]=512+i;
//	wf[512+i]=i;
//}
    //para guardar los datos en la posicion de memoria correspondiente:
//    uint32_t *puntero = wf;
//    uint32_t *posicion_memoria = (uint32_t *)parte2mem; // parte2mem= 0x2007C000+0x2000;

//    for (int i = 0; i < 1024; i++) {
//        *(posicion_memoria + i) = *((uint32_t *)puntero + i);
//    }
//}

//void dividir(){
//    uint32_t *posicion_memoria = (uint32_t *)0x2007C000;
//    for (uint32_t i = 0; i < (0x2000/4); i++) {// 0x2000/4 = cant de datos(muestras)
//        *(posicion_memoria + i) = (*posicion_memoria + i)/4;
//    }
//}

//*/
