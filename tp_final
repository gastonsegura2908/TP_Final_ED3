
// TRABAJO TP FINAL ELECTRONICA DIGITAL 3
///*

// ADC en modo timer pero en el handler

#include "LPC17xx.h"
#include "lpc17xx_dac.h"
#include "lpc17xx_adc.h"
#include "lpc17xx_timer.h"
#include "lpc17xx_pinsel.h"
#include "lpc17xx_gpdma.h"
#include "lpc17xx_exti.h"
#include "lpc17xx_gpio.h"
#include "lpc17xx_uart.h"
#include <stdio.h>
#include <string.h>

#include <math.h>

#define PIN_20 ((uint32_t)(1<<20))
#define PIN_21 ((uint32_t)(1<<21))
#define PIN_6 ((uint32_t)(1<<6))

//uint8_t prueba=0;

//uint8_t senialHum = '0';//para sincronizar con la app
//uint8_t senialTem = '9';//para sincronizar con la app
//uint8_t fin[]={'\r','\n'};//para sincronizar con la app

volatile uint16_t ADC5Valueoriginal=0;//resultado conversion temperatura // SACAR ++++
volatile uint16_t ADC4Valueoriginal=0;//resultado conversion humedad //  SACAR ++++++
volatile uint16_t ADC5Value=0;//resultado conversion temperatura
volatile uint16_t ADC4Value=0;//resultado conversion humedad
//uint16_t valoresHum[10];
//uint16_t valoresTem[10];

//volatile uint8_t ValSentHum[1];
//volatile uint8_t ValSentTem[1];

char resultadoHum[]=" ";// todo
char resultadoTem[]=" ";// todo

//volatile uint8_t ValSentHum[]={'48',(uint8_t)resultado,'\r','\n'}; //'48'=0 //valor a enviar por transmision //+++++++++
//volatile uint8_t ValSentTem[]={'57',resultado,'\r','\n'};//'57'=9 //valor a enviar por transmision  //+++++++++
//volatile uint8_t hola[]={1,10,200};
//volatile uint8_t ValSentHum[]={'4','0','\r','\n'}; //valor a enviar por transmision //+++++++++
//volatile uint8_t ValSentTem[]={'9','2','\r','\n'};//valor a enviar por transmision  //+++++++++
//volatile uint8_t prueba[]={1,10,200};

uint8_t pul0;// pulsador para cambiar de modo

uint8_t SelSensor;// todo . con 0 los dos apagados,con 1 usamos el sensor de humedad y con 2 el de temperatura. se cambia con pulsador y con uart

uint8_t flagpul;//para antirebote

uint8_t info[1] = ""; // todo

	void confPIN();
	void configADC(uint8_t num);

	void confEXTINT();
	void confUart();
	void confUartRecib();

	void confTIMER2();
	void confTIMER1(); // configuracion para antirebote
	void confTIMER0();// timer para mandar cada 2 segundos la tranmision uart de los datos de los sensores analogicos

	void confDMA();// configuramos el canal para mandar los datos sensor analogico de HUMEDAD por uart a pc usando dma

	void itoa(uint16_t num, char* str);
	void numtoarray(uint16_t num,uint16_t array[]);

int main(){
	uint32_t value=0;// sirve para el breakpoint de despues
	GPIO_ClearValue(1,PIN_20);
	GPIO_ClearValue(1,PIN_21);
	GPIO_ClearValue(2,PIN_6);

	SelSensor=2;// todo
	pul0=1;
	flagpul=0;

	confPIN(); //configuramos todos los pines
	confEXTINT();//configuramos las interrupciones externa

	confUart();
	//configADC(2);//1:humedad ,2: Temperatura

	//confDMA();
	//confUartRecib();

	confTIMER2();
	confTIMER1();// antirebote
	//confTIMER0();//enviar los datos

	TIM_ResetCounter(LPC_TIM2);
	TIM_ResetCounter(LPC_TIM1);
	//TIM_ResetCounter(LPC_TIM0);

	while(1){
		value++;// poner un breakpoint aca e ir apretando resumen para ver como funciona
	}

	return 0;
}

void confPIN(){
	GPIO_SetDir(1,PIN_20,1);
	GPIO_SetDir(1,PIN_21,1);
	GPIO_SetDir(2,PIN_6,1);

	PINSEL_CFG_Type structPINADC5;// ADC0.5 - sensor de temperatura
	structPINADC5.Pinnum=31;
	structPINADC5.Portnum=1;
	structPINADC5.Funcnum=3;
	structPINADC5.Pinmode=2;
	PINSEL_ConfigPin(&structPINADC5);

	PINSEL_CFG_Type structPINADC4;// ADC0.4 - sensor de humedad
	structPINADC4.Pinnum=30;
	structPINADC4.Portnum=1;
	structPINADC4.Funcnum=3;
	structPINADC4.Pinmode=2;
	PINSEL_ConfigPin(&structPINADC4);

	PINSEL_CFG_Type structPINEXT0;// PINEXT 2.10. LED azul
	structPINEXT0.Pinnum=10;
	structPINEXT0.Portnum=2;
	structPINEXT0.Funcnum=1;
	structPINEXT0.Pinmode=0;//pull up
	PINSEL_ConfigPin(&structPINEXT0);

	PINSEL_CFG_Type PinCfg;
	//configuracion pin de TX2 y RX2
	PinCfg.Funcnum = 1;
	PinCfg.OpenDrain = 0;
	PinCfg.Pinmode = 0;
	PinCfg.Pinnum = 10;
	PinCfg.Portnum = 0;
	PINSEL_ConfigPin(&PinCfg);
	PinCfg.Pinnum = 11;
	PINSEL_ConfigPin(&PinCfg);
	return;

}


void confTIMER0()// timer para ENVIAR cada 2 segundos los datos de los sensores
{
	TIM_TIMERCFG_Type    struct_config;
	TIM_MATCHCFG_Type    struct_match;

	struct_config.PrescaleOption    =    TIM_PRESCALE_TICKVAL;
	struct_config.PrescaleValue     =    1;

	struct_match.MatchChannel       =    0;
	struct_match.IntOnMatch         =    ENABLE; //habilitamos las interrupciones por timer
	struct_match.ResetOnMatch       =    ENABLE;//resetea el contador del timer cuando se produce un match
	struct_match.StopOnMatch        =    DISABLE; //no detiene el contador del timer cuando se produce un match
	struct_match.ExtMatchOutputType =    TIM_EXTMATCH_NOTHING;

	struct_match.MatchValue         =    37500000-1;//1.5 segundos

	TIM_Init(LPC_TIM0, TIM_TIMER_MODE, &struct_config); //se prende el TIMER0, se configura la division del clock del periferico, y se
	//configura el timer como modo temporizador y ademas se retesea el contador y se lo saca del reset
	TIM_ConfigMatch(LPC_TIM0, &struct_match); //carga todas las configuraciones del struct_match en ls registros correspondientes

	TIM_ResetCounter(LPC_TIM0);
	TIM_Cmd(LPC_TIM0, ENABLE); //habilita el contador del timer

	NVIC_EnableIRQ(TIMER0_IRQn);

	return;
}

void confTIMER1(){
	TIM_TIMERCFG_Type    struct_config;
	TIM_MATCHCFG_Type    struct_match;

	struct_config.PrescaleOption    =    TIM_PRESCALE_TICKVAL;
	struct_config.PrescaleValue     =    1;

	struct_match.MatchChannel       =    0;
	struct_match.IntOnMatch         =    ENABLE; //habilitamos las interrupciones por timer
	struct_match.ResetOnMatch       =    ENABLE;//resetea el contador del timer cuando se produce un match
	struct_match.StopOnMatch        =    DISABLE; //se detiene el contador del timer cuando se produce un match
	struct_match.ExtMatchOutputType =    TIM_EXTMATCH_NOTHING;

	struct_match.MatchValue         =    25000000-1;//0.5 segundos

	TIM_Init(LPC_TIM1, TIM_TIMER_MODE, &struct_config); //se prende el TIMER1, se configura la division del clock del periferico, y se
	//configura el timer como modo temporizador y ademas se retesea el contador y se lo saca del reset
	TIM_ConfigMatch(LPC_TIM1, &struct_match); //carga todas las configuraciones del struct_match en ls registros correspondientes

	TIM_ResetCounter(LPC_TIM1);
	TIM_Cmd(LPC_TIM1, ENABLE); //habilita el contador del timer. todo

	NVIC_EnableIRQ(TIMER1_IRQn);

	return;
}

void confTIMER2()// timer para ENVIAR cada 2 segundos los datos de los sensores
{
	TIM_TIMERCFG_Type    struct_config;
	TIM_MATCHCFG_Type    struct_match;

	struct_config.PrescaleOption    =    TIM_PRESCALE_TICKVAL;
	struct_config.PrescaleValue     =    1;

	struct_match.MatchChannel       =    0;
	struct_match.IntOnMatch         =    ENABLE; //habilitamos las interrupciones por timer
	struct_match.ResetOnMatch       =    ENABLE;//resetea el contador del timer cuando se produce un match
	struct_match.StopOnMatch        =    DISABLE; //no detiene el contador del timer cuando se produce un match
	struct_match.ExtMatchOutputType =    TIM_EXTMATCH_NOTHING;

	struct_match.MatchValue         =    50000000-1;//1 segundos

	TIM_Init(LPC_TIM2, TIM_TIMER_MODE, &struct_config); //se prende el TIMER0, se configura la division del clock del periferico, y se
	//configura el timer como modo temporizador y ademas se retesea el contador y se lo saca del reset
	TIM_ConfigMatch(LPC_TIM2, &struct_match); //carga todas las configuraciones del struct_match en ls registros correspondientes

	TIM_ResetCounter(LPC_TIM2);
	TIM_Cmd(LPC_TIM2, ENABLE); //habilita el contador del timer

	NVIC_EnableIRQ(TIMER2_IRQn);

	return;
}

void configADC(uint8_t num)// convierte la señal analogica de los sensores analogicos,en digital
{
	///CONFIGURACION ADC: -----------------///
	 //Nuestro CCLK es de 100MHz y configuramos el divisor de periferico a 8
	 //CCLK/divP = 100MHz/8 = 12,5MHz
	 //Al utilizar el modo controlado necesito 65 ciclos de reloj
	 //para establecer la muestra.
	 //12,5MHz/65 = 195312 Hz, siendo la frecuencia de trabajo maxima configurable
	//-------------------------------------

	//LPC_SC->PCLKSEL0 |=(3<<24);
	//ADC_Init(LPC_ADC, 200000); //ENCIENDO ADC
	//ADC_IntConfig(LPC_ADC,ADC_ADINTEN4,SET);
	//ADC_IntConfig(LPC_ADC,ADC_ADINTEN5,SET);
	//ADC_ChannelCmd(LPC_ADC, ADC_CHANNEL_4,ENABLE);
	//ADC_ChannelCmd(LPC_ADC, ADC_CHANNEL_5,ENABLE);
	//ADC_StartCmd(LPC_ADC, ADC_START_CONTINUOUS);//ADC_START_CONTINUOUS=0
	//ADC_BurstCmd(LPC_ADC, ENABLE);//Modo burst

	ADC_Init(LPC_ADC, 200000); //ENCIENDO ADC
	if(num==0){
		ADC_ChannelCmd(LPC_ADC, ADC_CHANNEL_4,DISABLE); //humedad
		ADC_ChannelCmd(LPC_ADC, ADC_CHANNEL_5,DISABLE); //temperatura
		GPIO_ClearValue(1,PIN_20);
		GPIO_ClearValue(1,PIN_21);
	}else if(num==1){
		ADC_ChannelCmd(LPC_ADC, ADC_CHANNEL_4,ENABLE); //humedad
		ADC_ChannelCmd(LPC_ADC, ADC_CHANNEL_5,DISABLE); //temperatura
		GPIO_SetValue(1,PIN_20);
		GPIO_ClearValue(1,PIN_21);
	}else if(num==2){
		ADC_ChannelCmd(LPC_ADC, ADC_CHANNEL_4,DISABLE); //humedad
		ADC_ChannelCmd(LPC_ADC, ADC_CHANNEL_5,ENABLE); //temperatura
		GPIO_ClearValue(1,PIN_20);
		GPIO_SetValue(1,PIN_21);
	}

	ADC_BurstCmd(LPC_ADC, DISABLE);//Modo controlado // todo
	ADC_StartCmd(LPC_ADC, ADC_START_NOW);    //START CON MATCH, DEBE MUESTREAR CADA 1 SE
	ADC_IntConfig(LPC_ADC, ADC_ADGINTEN, SET);//Activo las interrupciones

	ADC_GlobalGetStatus(LPC_ADC, 1); //Bajo la bandera
	NVIC_EnableIRQ(ADC_IRQn);

	return;
}

void confUart(){ // SACAR . todo
	UART_CFG_Type UARTConfigStruct;//variable auxiliar. es una estructura que es utilizada por las funciones del driver  para mostrar/sacar valores para realizar la configuracion
	UART_FIFO_CFG_Type UARTFIFOConfigStruct;
	UART_ConfigStructInit(&UARTConfigStruct);
	//inicializa perif rico
	UART_Init(LPC_UART2, &UARTConfigStruct);

	UARTFIFOConfigStruct.FIFO_DMAMode = ENABLE;// todo . /// Habilita la escritura de la FIFO por DMA
	UARTFIFOConfigStruct.FIFO_Level = UART_FIFO_TRGLEV0;
	UARTFIFOConfigStruct.FIFO_ResetRxBuf = ENABLE;
	UARTFIFOConfigStruct.FIFO_ResetTxBuf = ENABLE;

	//Inicializa FIFO
	UART_FIFOConfig(LPC_UART2, &UARTFIFOConfigStruct);//funcion que lleva a cabo la inicializacion
	//Habilita transmisi n
	UART_TxCmd(LPC_UART2, ENABLE);
	return;
}

void confUartRecib(void){

	UART_CFG_Type      UARTConfigStruct;
	UART_FIFO_CFG_Type UARTFIFOConfigStruct;
	//configuraci�n por defecto:
	UART_ConfigStructInit(&UARTConfigStruct);
	//inicializa perif�rico
	UART_Init(LPC_UART2, &UARTConfigStruct);
	//Inicializa FIFO
	UART_FIFOConfigStructInit(&UARTFIFOConfigStruct);
	UARTFIFOConfigStruct.FIFO_DMAMode = ENABLE;
	UART_FIFOConfig(LPC_UART2, &UARTFIFOConfigStruct);
	// Habilita interrupci�n por el RX del UART
	UART_IntConfig(LPC_UART2, UART_INTCFG_RBR, ENABLE);
	// Habilita interrupci�n por el estado de la linea UART
	UART_IntConfig(LPC_UART2, UART_INTCFG_RLS, ENABLE);
	//NVIC_SetPriority(UART2_IRQn, 1);
	//Habilita interrupci�n por UART2
	NVIC_EnableIRQ(UART2_IRQn);
	return;
}

void confEXTINT(){
	EXTI_Init();
	EXTI_InitTypeDef structEXTINT0;
	structEXTINT0.EXTI_Line=EXTI_EINT0;//led azul
	structEXTINT0.EXTI_Mode=EXTI_MODE_LEVEL_SENSITIVE;
	structEXTINT0.EXTI_polarity=EXTI_POLARITY_LOW_ACTIVE_OR_FALLING_EDGE;
	EXTI_Config(&structEXTINT0);
	EXTI_ClearEXTIFlag(EXTI_EINT0);//EINT0 ya q usamos p2.10

	NVIC_EnableIRQ(EINT0_IRQn);//EINT0 ya q usamos p2.10
}

void EINT0_IRQHandler(){// // todo
	if(pul0==0 && flagpul==0){
		GPIO_ClearValue(2,PIN_6);
		pul0=1;
		flagpul=1;
		//TIM_Cmd(LPC_TIM0, ENABLE);
		confTIMER0();
	}else if(pul0==1 && flagpul==0){
		GPIO_SetValue(2,PIN_6);
		pul0=0;
		flagpul=1;
		//TIM_Cmd(LPC_TIM0, ENABLE);
		confTIMER0();
	}

	EXTI_ClearEXTIFlag(EXTI_EINT0);
}

void confDMA() // configuramos el canal para recibir datos de la aplicacion // todo
{
	NVIC_DisableIRQ(DMA_IRQn);

	GPDMA_Init();                // Inicializo el controlador de DMA

	GPDMA_Channel_CFG_Type DMAUARTConfig;
	DMAUARTConfig.ChannelNum = 0;
	DMAUARTConfig.SrcMemAddr = 0;
	DMAUARTConfig.DstMemAddr = (uint32_t)(SelSensor);
	DMAUARTConfig.TransferSize = sizeof(SelSensor);
	DMAUARTConfig.TransferWidth = 0;
	DMAUARTConfig.TransferType = GPDMA_TRANSFERTYPE_P2M;
	DMAUARTConfig.SrcConn = GPDMA_CONN_UART2_Rx;
	DMAUARTConfig.DstConn = 0;
	DMAUARTConfig.DMALLI = 0;

	GPDMA_Setup(&DMAUARTConfig);

	return;
}


void ADC_IRQHandler(){
	if(LPC_ADC->ADDR5 &(1<<31)){ // bit DONE del canal 5
		ADC5Valueoriginal = ((LPC_ADC->ADDR5)>>4) & 0xFFF;
		ADC5Value = ((ADC5Valueoriginal * 3.3 * 100) / 4096)-5;
		//numtoarray(ADC5Value,valoresTem);
		itoa(ADC5Value, resultadoTem);// temperatura
		//UART_Send(LPC_UART2,(uint8_t*)resultadoTem,sizeof(resultadoTem), BLOCKING);// todo

	}else if(LPC_ADC->ADDR4 &(1<<31)){  // bit DONE del canal 4
		ADC4Valueoriginal = ((LPC_ADC->ADDR4)>>4) & 0xFFF;
		//uint16_t value=((ADC4Valueoriginal-1.25)/(3.3-1.25))*4095;
		//ADC4Valueoriginal = LPC_ADC->ADDR4;
		ADC4Value= (ADC4Valueoriginal*3.3*100)/4095; // obtenemos el valor de humedad
		//ADC4Value= (100*(500-ADC4Valueoriginal))/(170-ADC4Valueoriginal);
		//ADC4Value= ((ADC4Valueoriginal-2200)*100)/(4095-2200);
		//numtoarray(ADC4Value,valoresHum);

		itoa(ADC4Value,resultadoHum); // humedad // todo
		//UART_Send(LPC_UART2,(uint8_t*)resultadoHum,sizeof(resultadoHum), BLOCKING); // todo
	}

}

void TIMER0_IRQHandler()//0.5 segundo.hanndler del timer para mandar datos de los sensores  por uart
{
	//uint8_t info[]={0x34, 0x35,'\n','\r'};
	//UART_Send(LPC_UART2, info, sizeof(info), BLOCKING);
	flagpul=0;// habilita pulsadores
	TIM_ClearIntPending(LPC_TIM0,TIM_MR0_INT);

	return;
}

void TIMER1_IRQHandler()//
{
	//uint8_t info[]={0x36, 0x37,'\n','\r'};
	//UART_Send(LPC_UART2, info, sizeof(info), BLOCKING);

	configADC(SelSensor);

	TIM_ClearIntPending(LPC_TIM1,TIM_MR0_INT);

	return;
}

void TIMER2_IRQHandler()//2 segundo.antirebote
{

	//-----------
	//uint8_t info[]={0x38, 0x39,'\n','\r'};
	//UART_Send(LPC_UART2, info, sizeof(info), BLOCKING);

	//prueba++;
	//static uint16_t prom=0;
	//prom=0;
	if(SelSensor==1){
		//for(uint8_t i=0;i<10;i++){
		//	prom=prom+valoresHum[i];
		//}
		//prom=prom/10;
		//itoa(prom,resultadoHum); // humedad

		uint8_t text[]={'H','\n'};
		UART_Send(LPC_UART2, text, sizeof(text), BLOCKING);

		UART_Send(LPC_UART2,(uint8_t*)resultadoHum,sizeof(resultadoHum), BLOCKING);
	}else if(SelSensor==2){
	//prom=0;
		//for(uint8_t i=0;i<10;i++){
		//	prom=prom+valoresTem[i];
		//}
		//prom=prom/10;
		//itoa(prom, resultadoTem);// temperatura

		uint8_t text[]={'T','\n'};
		UART_Send(LPC_UART2, text, sizeof(text), BLOCKING);

		UART_Send(LPC_UART2,(uint8_t*)resultadoTem,sizeof(resultadoTem), BLOCKING);
	}
	uint8_t info[]={'\n'};
	UART_Send(LPC_UART2, info, sizeof(info), BLOCKING);
	//--------------------------
	TIM_ClearIntPending(LPC_TIM2,TIM_MR0_INT);
	return;
}

void itoa(uint16_t num, char* str)
{
    int i = 0;

    if (num == 0)                // Manejo del numero 0 de forma explicita
    {
        str[i++]= '0';
        str[i++]= '\0';
        str[i] 	= '\0';
        return;
    }


    while (num != 0)            // Se procesa cada digito de manera individual
    {
        int rem = num % 10;
        str[i++] = (rem > 9)? (rem-10) + 'a' : rem + '0';   // Devuelve el equivalente en ASCII en orden inverso
        num = num/10;
    }

    if(i==1){
    	str[i++] = '\0';
    }
    str[i] = '\0';

    int start = 0;
    int end = i -1;
    char aux;

	while (start < end)       // Invierto los caracteres del string
	{
		aux = *(str+start);
		*(str+start) = *(str+end);
		*(str+end) = aux;
		start++;
		end--;
	}
    return;
}

void numtoarray(uint16_t num,uint16_t *array){
	for(uint8_t i=9;i>0;i--){
		array[i]=array[i-1];
	}
	array[0]=num;
	}

void UART2_IRQHandler(void){
	uint32_t intsrc, tmp, tmp1;
	//Determina la fuente de interrupci�n
	intsrc = UART_GetIntId(LPC_UART2);
	tmp = intsrc & UART_IIR_INTID_MASK;
	// Eval�a Line Status
	if (tmp == UART_IIR_INTID_RLS){
		tmp1 = UART_GetLineStatus(LPC_UART2);
		tmp1 &= (UART_LSR_OE | UART_LSR_PE | UART_LSR_FE \
				| UART_LSR_BI | UART_LSR_RXFE);
		// ingresa a un Loop infinito si hay error
		if (tmp1) {
			while(1){};
		}
	}
	// Receive Data Available or Character time-out
	if ((tmp == UART_IIR_INTID_RDA) || (tmp == UART_IIR_INTID_CTI)){
		UART_Receive(LPC_UART2, info, sizeof(info), NONE_BLOCKING);
	}
	SelSensor=info[0];//todo
	return;
}
//*/
